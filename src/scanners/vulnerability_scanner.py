"""
Vulnerability Scanner
Uses Gemini 3 Pro to detect security vulnerabilities with deep reasoning
"""

import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime

from src.core.gemini_client import GeminiClient
from src.core.marathon_agent import MarathonAgent
from src.simulators.attack_simulator import AttackSimulator
from src.utils.logger import setup_logger

logger = setup_logger(__name__)


class VulnerabilityScanner:
    """
    Advanced vulnerability scanner powered by Gemini 3 Pro.
    Uses extended reasoning and 1M context to find complex security issues.
    """
    
    # OWASP Top 10 and common vulnerability types
    VULNERABILITY_TYPES = {
        'sql-injection': {
            'name': 'SQL Injection',
            'cwe': 'CWE-89',
            'description': 'Improper neutralization of special elements in SQL commands'
        },
        'xss': {
            'name': 'Cross-Site Scripting',
            'cwe': 'CWE-79',
            'description': 'Improper neutralization of input during web page generation'
        },
        'command-injection': {
            'name': 'Command Injection',
            'cwe': 'CWE-78',
            'description': 'Improper neutralization of special elements in OS commands'
        },
        'path-traversal': {
            'name': 'Path Traversal',
            'cwe': 'CWE-22',
            'description': 'Improper limitation of pathname to restricted directory'
        },
        'insecure-deserialization': {
            'name': 'Insecure Deserialization',
            'cwe': 'CWE-502',
            'description': 'Deserialization of untrusted data'
        },
        'broken-auth': {
            'name': 'Broken Authentication',
            'cwe': 'CWE-287',
            'description': 'Improper authentication implementation'
        },
        'sensitive-data-exposure': {
            'name': 'Sensitive Data Exposure',
            'cwe': 'CWE-200',
            'description': 'Exposure of sensitive information'
        },
        'xxe': {
            'name': 'XML External Entities',
            'cwe': 'CWE-611',
            'description': 'Improper restriction of XML external entity references'
        },
        'broken-access-control': {
            'name': 'Broken Access Control',
            'cwe': 'CWE-639',
            'description': 'Authorization bypass through user-controlled key'
        },
        'security-misconfiguration': {
            'name': 'Security Misconfiguration',
            'cwe': 'CWE-16',
            'description': 'Configuration vulnerabilities'
        }
    }
    
    def __init__(self, gemini_client: GeminiClient, enable_attack_simulation: bool = True):
        """
        Initialize vulnerability scanner.
        
        Args:
            gemini_client: Configured Gemini client
            enable_attack_simulation: Enable actual attack simulation (default: True)
        """
        self.gemini_client = gemini_client
        self.vulnerabilities = []
        self.attack_simulator = AttackSimulator(enable_sandbox=enable_attack_simulation) if enable_attack_simulation else None
    
    async def scan(
        self,
        analysis_result: Dict[str, Any],
        marathon_agent: MarathonAgent,
        focus_types: Optional[List[str]] = None
    ) -> List[Dict[str, Any]]:
        """
        Perform comprehensive vulnerability scan.
        
        Args:
            analysis_result: Codebase analysis from CodebaseAnalyzer
            marathon_agent: Marathon agent for long-running operations
            focus_types: Optional list of specific vulnerability types to focus on
            
        Returns:
            List of detected vulnerabilities
        """
        logger.info("Starting vulnerability scan")
        
        # Determine which vulnerability types to scan for
        scan_types = focus_types if focus_types else list(self.VULNERABILITY_TYPES.keys())
        
        # Phase 1: Quick triage using critical paths
        high_priority_files = await self._triage_files(
            analysis_result['critical_paths'],
            analysis_result['files']
        )
        
        logger.info(f"Identified {len(high_priority_files)} high-priority files for deep scan")
        
        # Phase 2: Deep scan on each file
        scan_tasks = []
        for file_info in high_priority_files[:50]:  # Limit to top 50 for demo
            task = self._scan_file(
                file_info,
                analysis_result,
                scan_types,
                marathon_agent
            )
            scan_tasks.append(task)
        
        # Execute scans with controlled concurrency
        results = []
        for batch in self._batch_tasks(scan_tasks, batch_size=5):
            batch_results = await asyncio.gather(*batch, return_exceptions=True)
            results.extend([r for r in batch_results if isinstance(r, list)])
        
        # Flatten results
        for result_list in results:
            self.vulnerabilities.extend(result_list)
        
        # Phase 3: Rank by severity
        self.vulnerabilities = self._rank_vulnerabilities(self.vulnerabilities)
        
        logger.info(f"Scan complete: {len(self.vulnerabilities)} vulnerabilities found")
        
        return self.vulnerabilities
    
    async def _triage_files(
        self,
        critical_paths: List[Dict[str, Any]],
        all_files: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Prioritize files for scanning based on criticality."""
        
        # Build a score for each file
        file_scores = {}
        
        for file_info in all_files:
            score = 0
            file_path = file_info['relative_path']
            
            # Base score on file characteristics
            score += len(file_info.get('functions', [])) * 2
            score += len(file_info.get('imports', [])) * 1
            
            # Boost score if in critical paths
            critical_count = sum(
                1 for cp in critical_paths 
                if cp['file'] == file_path
            )
            score += critical_count * 10
            
            # Boost for security-related imports
            security_imports = [
                'sql', 'sqlite', 'mysql', 'postgres',
                'subprocess', 'os', 'sys', 'eval',
                'pickle', 'json', 'xml', 'requests',
                'auth', 'crypto', 'jwt', 'session'
            ]
            
            for imp in file_info.get('imports', []):
                if any(sec in imp.lower() for sec in security_imports):
                    score += 5
            
            file_scores[file_path] = score
        
        # Sort by score and return top files
        sorted_files = sorted(
            all_files,
            key=lambda f: file_scores.get(f['relative_path'], 0),
            reverse=True
        )
        
        return sorted_files
    
    async def _scan_file(
        self,
        file_info: Dict[str, Any],
        analysis_result: Dict[str, Any],
        scan_types: List[str],
        marathon_agent: MarathonAgent
    ) -> List[Dict[str, Any]]:
        """
        Deep scan a single file for vulnerabilities.
        
        Args:
            file_info: File information from analysis
            analysis_result: Full codebase analysis
            scan_types: Vulnerability types to check
            marathon_agent: Marathon agent for orchestration
            
        Returns:
            List of vulnerabilities found in this file
        """
        
        file_vulns = []
        
        try:
            # Read file content
            from pathlib import Path
            file_path = Path(file_info['path'])
            
            if not file_path.exists():
                return []
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                code = f.read()
            
            # Prepare context for Gemini
            context = {
                'total_loc': analysis_result['total_loc'],
                'dependencies': file_info.get('imports', []),
                'data_flows': [
                    df for df in analysis_result['data_flows']
                    if df['file'] == file_info['relative_path']
                ],
                'functions': file_info.get('functions', []),
                'classes': file_info.get('classes', [])
            }
            
            # Scan with Gemini
            result = await self.gemini_client.analyze_code_security(
                code=code,
                language='python',  # TODO: detect language from file extension
                focus_areas=scan_types
            )
            
            # Parse vulnerabilities from response
            if result['success'] and result.get('structured_data'):
                vulns = result['structured_data']
                
                # Handle both single dict and list of dicts
                if isinstance(vulns, dict) and 'vulnerabilities' in vulns:
                    vulns = vulns['vulnerabilities']
                elif isinstance(vulns, dict):
                    vulns = [vulns]
                
                for vuln in vulns if isinstance(vulns, list) else []:
                    file_vulns.append({
                        'id': f"VULN-{len(self.vulnerabilities) + len(file_vulns) + 1:04d}",
                        'file': file_info['relative_path'],
                        'type': vuln.get('type', 'Unknown'),
                        'severity': vuln.get('severity', 'medium').lower(),
                        'title': vuln.get('title', 'Security Vulnerability'),
                        'description': vuln.get('description', vuln.get('explain', '')),
                        'location': vuln.get('location', {
                            'line': vuln.get('line', 0),
                            'code': vuln.get('code_snippet', '')
                        }),
                        'exploit': vuln.get('exploit', 'No exploit details'),
                        'fix_suggestion': vuln.get('fix', 'No fix suggested'),
                        'cwe': vuln.get('cwe', 'CWE-UNKNOWN'),
                        'confidence': vuln.get('confidence', 'medium'),
                        'attack_simulation': None  # Will be populated if simulation runs
                    })
                    
                # REAL ATTACK SIMULATION - This is what separates us from simple scanners!
                if self.attack_simulator and len(file_vulns) > 0:
                    logger.info(f"Running attack simulations for {len(file_vulns)} vulnerabilities")
                    for vuln in file_vulns:
                        try:
                            # Generate exploit payload using Gemini
                            exploit_result = await self.gemini_client.simulate_attack(
                                vulnerability=vuln,
                                code_context=code
                            )
                            
                            if exploit_result['success'] and exploit_result.get('structured_data'):
                                payload = exploit_result['structured_data'].get('payload', vuln.get('exploit', ''))
                                
                                # Actually test the exploit
                                sim_result = await self.attack_simulator.simulate_attack(
                                    vulnerability=vuln,
                                    code_snippet=code,
                                    exploit_payload=payload
                                )
                                
                                vuln['attack_simulation'] = sim_result
                                
                                # Upgrade severity if actually exploitable
                                if sim_result.get('exploitable'):
                                    logger.warning(f"⚠️  CONFIRMED EXPLOITABLE: {vuln['id']}")
                                    if vuln['severity'] == 'medium':
                                        vuln['severity'] = 'high'
                                    elif vuln['severity'] == 'low':
                                        vuln['severity'] = 'medium'
                        except Exception as e:
                            logger.debug(f"Attack simulation failed for {vuln['id']}: {e}")
                            vuln['attack_simulation'] = {'success': False, 'error': str(e)}
            
        except Exception as e:
            logger.error(f"Failed to scan {file_info['relative_path']}: {e}")
        
        return file_vulns
    
    def _rank_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Rank vulnerabilities by severity and exploitability."""
        
        severity_order = {
            'critical': 4,
            'high': 3,
            'medium': 2,
            'low': 1
        }
        
        def vuln_score(v):
            severity = severity_order.get(v.get('severity', 'medium'), 2)
            confidence_map = {'high': 3, 'medium': 2, 'low': 1}
            confidence = confidence_map.get(v.get('confidence', 'medium'), 2)
            return severity * 10 + confidence
        
        return sorted(vulnerabilities, key=vuln_score, reverse=True)
    
    def _batch_tasks(self, tasks: List, batch_size: int = 5):
        """Split tasks into batches for controlled concurrency."""
        for i in range(0, len(tasks), batch_size):
            yield tasks[i:i + batch_size]
    
    def get_summary(self) -> Dict[str, Any]:
        """Get vulnerability scan summary."""
        
        by_severity = {}
        by_type = {}
        
        for vuln in self.vulnerabilities:
            severity = vuln.get('severity', 'medium')
            vuln_type = vuln.get('type', 'Unknown')
            
            by_severity[severity] = by_severity.get(severity, 0) + 1
            by_type[vuln_type] = by_type.get(vuln_type, 0) + 1
        
        return {
            'total': len(self.vulnerabilities),
            'by_severity': by_severity,
            'by_type': by_type,
            'critical_count': by_severity.get('critical', 0),
            'high_count': by_severity.get('high', 0),
            'medium_count': by_severity.get('medium', 0),
            'low_count': by_severity.get('low', 0)
        }
